\chapter{Evaluation}
In Chapter \ref{chap:intro}, the key aims for the project were established, and using these the project was defined. This chapter will evaluate whether these aims and deliverables have been met through a variety of methods. From these aims, a set of formal requirements were defined in Chapter \ref{chap:requirements}, describing in detail what the project must complete in order to be considered successful. This chapter evaluates the final project deliverable against the aforementioned aims and requirements. This is done through a variety of methods, including evaluation against Issie's core principles, evaluation of key functionality in the application, analysis of performance data, as well as interpretation of user feedback. 

\section{Evaluation against Project Aims}
The principal aim of the project was to explore novel ways in which interactivity could be added to automatic schematic-derived truth tables, and how these could be used as a fast aid to design combinational logic. Alongside the research, the main deliverable was stated as an updated version of Issie which featured these interactive truth tables. Additionally, an overarching aim was defined for the project; improving Issie in such a way that it is easier for students to understand the use of combinational logic in digital design. This section evaluates the improved version of Issie delivered by this project against these aims, ultimately concluding whether or not the aims were fulfilled.

Automatic schematic derived truth tables have been implemented using repeated simulation of the schematic. These truth tables are generated through repeated simulation of all input combinations, with the whole process taking under 1 second. A caveat on these schematic-derived truth tables is that they can only handle an input space 10 bits wide, placing a limit of 1024 rows on truth table size. While this is a theoretical limitation, as discussed during the design of the system, in practice it is unlikely that any user would be able to effectively comprehend a truth table of such a large size anyways. Additionally, the user has the option to re-generate the truth table with a tighter set of input constraints or with algebraic inputs to gain a more informative truth table. Both of these are examples of where \textit{interactivity} has been added to the original schematic-derived truth table. Using input constraints, users can limit the input space and find/verify patterns in the resultant outputs. Seeing all the cases in a well-formatted list is more convenient than having to repeatedly run simulations and remember the result. Output constraints enable the reverse; users can specify a set of outputs and see which inputs into the logic cause them to occur. In addition to these features, truth tables can be sorted, rearranged, and can have some of their output columns hidden. These are all interactive features which allow the user to re-organise or reduce the truth table to make it more informative.

Establishing that interactive schematic-derived truth tables were added and discussing the possible uses of these features is only one one part of the evaluation. Ultimately, the project can only be considered successful if the features added to Issie augment users' understanding of the combinational logic they are designing. In order to establish whether this was the case, 11 engineering students with beginner's level experience were provided with the updated version of Issie and asked to analyse five 'mystery' circuits using the truth table tab. Following this, they were asked a series of questions about their experience using the application. The methodology for this user experience testing is described in detail in Section \ref{sec:uxtest}, along with the results. 100\% of participants were able to correctly identify the combinational logic function implemented by mystery circuits 1 to 4, while just over 90\% were able to identify mystery sheet 5. These results imply that the added features to Issie do help users understand the relationships between inputs and outputs in combinational logic circuits. Additionally, the participants were themselves asked to evaluate the extent to which the updates were helpful. They were asked how much they agreed with the following statements:
\begin{center}
    \textit{Using truth tables made it easier to understand the relationship between inputs and outputs in combinational logic compared to looking at the schematic.} 
    
    \textit{The algebraic expressions in the truth table make it easy to understand the intended function of the circuit.}
\end{center}

The first statement had a score of 4.36, while the second statement had a score of 4.54. This indicates that most participants either agreed or strongly agreed with the statements. Therefore it can be said that the participants of the user experience survey agreed that the added methods for visualising combinational logic in Issie have helped them to better understand the relationships between inputs and outputs in the logic. 

To further verify this conclusion, an 8-bit ALU was analysed using the truth table functionality added by the project. The purpose of the test was to use the features to ascertain the logical function of the circuit. The successfully deduced function, along with part of the algebraic truth table used to deduce it, is described in Section \ref{sec:alu}. The ALU, which has an input space of over 8 million possible combinations, was reduced to a truth table with only 64 rows through algebraic reduction. Following analysis of the algebraic truth table, the behaviour of the ALU was narrowed down to 8 distinct cases. 
The fact that the relationships between the inputs and outputs for such a complex schematic, featuring numerous components (including nested custom-components) can be inferred in this way suggests that the new methods for visualising combinational logic in Issie are effective and successfully fulfil the project aims.

\section{Evaluation against Issie's Core Principles}
Chapter \ref{chap:intro} outlined the three key principles of Issie. These stated that all new features added to Issie must be robust, obvious, and intuitive. This section looks over the nature of the additions made to Issie, and evaluates whether they align with these principles.
\subsection{Robustness}
Software is considered robust when it is able to behave correctly under exceptional circumstances, such as when presented with erroneous or malformed user input. In Section \ref{sec:testappstability}, the process of analysing the codebase to verify against exceptions and failures is described. This process found that the majority of functions used in the project's codebase were exception-free, and the few functions which could throw exceptions had checks or system-constraints implemented which would prevent against invalid arguments being passed to them. A similar verification process was also undertaken for cases where \codestyle{failwithf} is called, and also concluded that these cases would not occur due to checks and constraints. Finally, it was observed that even after hours of manual and user testing, no crashes or undefined behaviour was reported. These hours of use included a variety of interactions with the UI, many of which were malformed and would have resulted in errors were it not for the error checking and handling systems built into Issie.

This displayed resilience to crashes indicates that the decision to continue developing Issie in F\fsharp was the correct one. The majority of the application's data is immutable -- therefore by extension most of the functions are referentially transparent (deterministic). The resulting lack of dependency on shared mutable state means that function behaviour is far more predictable. Another key aspect of F\fsharp which greatly adds to the robustness of the codebase is the fact that every language construct is an expression. Every expression must return a value, and all conditional branches must return a value of the same type. The effect of this is that every case must be considered and explicitly handled, reducing undefined behaviour. When combined with F\fsharp's powerful type inference, courtesy of its Hindleyâ€“Milner type system, this means that even complex conditional statements or pattern matches are correctly analysed by the compiler. The \codestyle{evalExp} function, which is responsible for implementing the reduction rules for algebraic expressions, is an example of a large pattern match expression with many complicated cases. As well as generating warnings when specific expression cases weren't matched, it also did so when the cases were ordered in such a way that one would never be matched. This compile-time checking meant that many potential errors were caught as the code was being written, significantly reducing the likelihood of bugs being encountered at runtime.

In summary, following analysis of exception and failure cases, alongside observed stability in user-trials and language constructs, it can be said that the updated version of Issie delivered by this project is robust.
\subsection{Obviousness}
Issie is built to be obvious -- it should be clear to the user what is happening on their screen without any additional explanation. The user interface has been designed to be as clear as possible.
Buttons are labelled with verbs which succinctly describe what they do, and are colour coded in a consistent manner with Issie's existing buttons. An example of this is the colour coding of the \textit{Generate Truth Table} button. It is green if everything is correct and a truth table can successfully be generated, while it is yellow when there are issues that the user must resolve. In this scenario, clicking on the button clearly describes the error and highlights its source on the canvas. When the schematic contains sequential logic, the button is still green, but light in colour, communicating that while the schematic is correct, truth table generation is unavailable. Clicking this button then results in an error notification which informs users that truth table generation is only supported for combinational logic. In situations where the user is prevented from performing a certain action, such as applying an invalid constraint or DC reducing a truncated table, the button that would usually let them perform that action is greyed out and un-clickable. This disabling of the button, along with the changed mouse cursor, clearly communicates to the user that the action is forbidden under the current circumstances. A helpful warning message is either displayed near the button or as a tooltip to inform the user of the reason. This prevents them from becoming confused.
Toggles are used in two places: hiding/un-hiding truth table columns and toggling inputs between numeric values and algebra. The toggle states are differentiated by colour as well as text. This means that from a glance it is obvious which of the two states is currently selected for each toggle. 

While analysis of the various design patterns of the extensions made to Issie appears to show that they appear obvious, ultimately the obviousness of the features is best evaluated by real  end users. The user questionnaire presented participants with the following statement:
\begin{center}
    \textit{The functionality related to Truth Tables is clear and obvious in the UI.}
\end{center}
They were then asked to rank their opinion from Strongly Disagree (1) to Strongly Agree (5). As shown in Table \ref{tab:strongqs}, the average response score for this question was 4.63 out of 5. This indicates that most users either Agreed or Strongly Agreed that the truth table features in Issie are clear and obvious. Following the questionnaire, participants were given a free-form text box to voice any general feedback in. One response collected through this method stated that while most truth table functionality was clear, it was not hugely obvious what the "Reduce" button did at first glance. As the sheet that was open at the time did not contain any redundancies, the truth table did not change even after the user clicked the button out of curiosity. As a result, they were left slightly confused. This issue could be mitigated by 1) re-naming the button to something like "Remove Redundancies" to increase clarity, and 2) displaying a message stating there are no redundancies in the table if that is the case. 
With the exception of this comment, it is clear that the user experience with regard to the obviousness of the UI is positive. This indicates that while small improvements could be made, on the whole this project's additions to Issie align with its principle of obviousness.

\subsection{Intuitiveness}
Issie must be intuitive; users should not have to spend time and effort learning how to use features. This means that lab time can be spent learning Digital Electronics concepts, rather than figuring out the application. Consistency is a key factor in building an intuitive environment -- if multiple features work in the same predictable way then there is less for the user to deduce from the application. Care has been taken to maintain consistency with Issie's existing features, with code and behaviour being reused from the existing Step Simulator wherever possible to improve the experience of both the user and future developers. To ascertain the intuitiveness of the updated version of Issie, the user questionnaire presented participants with the following statement, and asked to what extent they agreed with it.
\begin{center}
    \textit{Once I found a feature, it was easy to figure out what it did and how to use it.}
\end{center}
As shown in Table \ref{tab:strongqs} this statement had an average response of 4.45, implying that as a whole users agreed or strongly agreed that features were easy to understand and use once they were found. This in turn indicates that the features are intuitive, and therefore align with Issie's core principles.

\section{Evaluation of Application Performance}
Section \ref{sec:performance} describes the measured performance for the application, along with the methodology used to obtain those results. From this, it is clear that the performance criteria set out in the requirements have been met. The average time taken to generate a truth table for a complex schematic is around 700ms, while other operations (bar one) on the truth table take under 100ms. The worst performing operation on the truth table by far is Don't Care reduction. On sheets with no redundancies, it still takes over 250ms on average to detect this. On sheets with multiple redundancies, such as a simple Mux4 circuit, it took up to around 2.6 seconds to completely reduce the truth table. This poor performance is likely due to brute-force nature of the reduction algorithm, which has a poor time complexity. If the $n$ represents the number of rows in the truth table, and $m$ represents the number of inputs, each call of the reduction algorithm has a worst case complexity of $O(m^3n^3)$. For a truth table with $r$ recursive inputs, the recursion function is called $r+1$ times. This terrible time complexity is likely due to the fact that the  algorithm applies a brute-force approach to DC reduction. For each input, all possible 'Don't Care' rows are calculated, and these are then each tested to check whether they are valid. Switching to some heuristic-based method will likely bring performance improvements. 

The use of immutable data structures also affects application performance. Operations that would usually mutate contents of data structures instead copy large chunks of data -- this adds overhead. Updating the values at specific indices in a list is particularly expensive. This operation is $O(n)$ by itself as F\fsharp lists are implemented as singly-linked lists, and on top of this the entire list must be copied to a new location in memory. Therefore, it is likely that badly performing functions, such as the brute-force reduction algorithm, could be optimised by replacing immutable data structures (e.g. Lists and Maps) with mutable structures (e.g. Arrays). This technique was successfully used to improve the efficiency of the Step Simulator earlier during Issie development.  However, even with its performance issues, DC reduction still takes less than 4 seconds, meaning that it fulfils the performance requirements outlined in Chapter \ref{chap:requirements}.

From a qualitative perspective, the application feels lightweight and responsive. No action (other than DC Reduction) creates a delay that loses the user's attention, and all UI operations appear instantaneous. This perception aligns with the measured timings in accordance with Robert Miller's descriptions of perceived responsiveness, which were summarised in Section \ref{sec:perfeffects}. This responsiveness means that the updated version of Issie, much like its predecessor, does not lose the user's attention and has a greater perceived interactivity, which in-turn improves the learning experience.

\section{Comparison Against Issie 3.0.0}
As of the time of writing, the latest release of Issie is version 3.0.0. In this version of Issie, combinational logic can only be visualised by either viewing the schematic diagram, or simulating specific input combinations in the step simulator. This section compares the updated version of Issie delivered by the project with Issie 3.0.0, highlighting the different areas in which the updated version improves Issie. Issie 3.0.0 is referred to as the base version, while the version of Issie delivered by the project is referred to as the updated version.

\paragraph{Consistent Top-Level UI} Issie 3.0.0's top level UI was analysed in \ref{sec:IssieUI}. One major issue found with it was its lack of consistency for running simulations. In Issie 3.0.0, the step simulator is accessed via a tab in the right section, while the waveform simulator is launched via a button in the top bar of the application. This results in a fourth tab appearing in the right section, which contains the actual wave simulation interface. This was deemed too inconsistent and confusing, and was therefore improved upon in the updated version of Issie. Now, all simulation activity (Step Simulator, Truth Table, Waveform Simulator) is contained in sub-tabs underneath a main simulations tab in the right section.

\paragraph{Viewing all Input/Output relationships} For smaller schematics (those that will not be truncated), truth tables allow for all pairs of input and output combinations to be viewed in one go. This is in contrast to the base version of Issie, where the user has to manually run multiple simulations. The results of these simulations are not stored anywhere, so to view all relationships in one place the user must write down the result of each simulation prior to simulating the next input combination. In addition to describing the whole schematic in a single, organised structure, this functionality is also useful in situations where the user may want to verify a specific batch of relationships hold true for some logic.

\paragraph{Easier to verify schematic behaviour} A major advantage of being able to view multiple pairs of input and output combinations at once is that it becomes much easier to verify whether the circuit built by the user actually implements the required function. In Issie 3.0.0, users can only verify circuit behaviour by manually running different simulations. This is a time-consuming and tedious process, meaning that users are likely to not do it properly. In contrast, not only do truth tables allow multiple simulation results to be viewed in one go, but they can be filtered with input constraints to allow results for specific cases to be viewed together. Algebraic truth tables take this one step further, with algebraic expressions representing the logical function for even easier verification.

\paragraph{Debugging parts of a schematic} When designing a schematic, there may be situations where a user has some part of their logic working correctly, but has errors (either syntactical or logical) elsewhere in the schematic. The ability to generate truth tables for partial selections of the sheet means that users can investigate or verify the behaviour of specific parts of the schematic, regardless of whether the rest of the schematic is complete. This has many benefits; when designing schematics users can test parts of the sheet as they go. When analysing/debugging schematics, users can take a divide and conquer approach by establishing what specific parts of the sheet do. In the base version of Issie, sub-parts of a design can only be simulated if they are contained within separate sheets. Therefore, if a user wished to debug a specific part of the logic in a sheet, they would have to recreate it in a separate sheet. This is a tedious process compared to simply selecting that part of the logic and generating a truth table for it.

\paragraph{Redundancy Detection} Through reduction with Don't Cares, redundancies in a logic design can be identified in the updated version of Issie. While this feature was envisaged as an analysis tool, it also aids logic design. If, due to some mistake an input is redundant in the designed logic, Don't Care reduction would clearly label it as so. In contrast, it may be difficult to spot such an issue when simply running simulations with the step simulator.

\section{Evaluation of Filtering Methods}
The size of the truth table can be reduced by filtering it with input and output constraints. The section for adding these constraints is collapsed under the \textit{Filter} menu option in the truth table tab. Input constraints are generally an effective way of manipulating an existing truth table to check for specific cases, especially when used on algebraic truth tables. For example, when analysing the ALU in Section \ref{sec:alu}, the input combinations which led to the 8 distinct cases were isolated and verified using input constraints on $X$ and $F$.

Output constraints can be used to observe which input combinations result in some specified output combination(s). This feature is often most effective when used in conjunction with other features. Prior to the implementation of algebraic truth tables, output constraints were very useful for finding which input combinations resulted in specific behaviour. For example, the following steps were used to determine the cases where the ALU was performing subtraction:
\begin{enumerate}
    \item Generate the numeric truth table
    \item Using input constraints, set the value of $A$ to a number, and $B$ to a smaller number (e.g. 21 and 7)
    \item Add the output constraint where $OUT$ is equal to $A -B$ (e.g. 14)
    \item Observe the values of the other controlling inputs $X$ and $F$
\end{enumerate}
While useful, there are limitations on output constraints. They are not as useful on truncated truth tables, because they filter the existing truncated truth table (1024 rows), rather than the complete theoretical truth table like the input constraints do. This means that the user may make incorrect deductions about the logic. Users are warned about this when they add output constraints, but there is a possibility that they might miss this warning. Unfortunately, there is not much that can be done to address this issue completely, as applying output constraints requires simulating the entire input space and then filtering the corresponding output space; this would be far too time-consuming for schematics with large input spaces. 
Another limitation of output constraints in Issie is that they are purely numerical, meaning that they cannot be applied to algebraic truth tables. Pure numerical output constraints also lack the ability to filter numeric truth tables based on relationships. Both these limitations could be overcome by introducing algebraic output constraints. The possibilities unlocked by implementing these in in the future are discussed in Section \ref{subsec:algoutputcons}.

\section{Evaluation of Reduction Methods}
\subsection{Algebraic Truth Tables}
Truth tables can be reduced by turning them into Algebraic truth tables. Users set specific inputs to algebraic terms, and the outputs in the truth table are displayed as functions of the algebraic terms.
In the user experience questionnaire, a majority of participants either agreed or strongly agreed that algebraic expressions in the truth table made it easier to understand the intended function of the circuit. This, in addition to the successful analysis of the ALU, indicates that the implementation of algebraic expressions in Issie has been effective and in line with the aims of the project. One of the major factors behind this effectiveness is the comprehensive set of algebraic reduction rules defined in Section \ref{subsec:redrules}, which can recognise and interpret a wide array of patterns. However, there were only a finite number of cases which could be implemented over the course of the project, meaning that there are some limitations to the extent certain schematics can be interpreted.

The N-bits Adder component in Issie is used for arithmetic operations, and this behaviour is used when constructing algebraic expressions during algebraic simulation. However, users can define their own ripple carry adders. Ripple-carry adders implement n-bit addition using multiple full adder components, meaning that they are built purely out of logic gates. This means that detecting arithmetic done using a ripple-carry adder requires a very complex reduction rule which checks for a specific combination of Boolean operations. A complex rule has already been written to detect full adders, but the additional challenge with ripple carry adders is that they can be n-bits wide. While the detection of n-bit ripple carry adders was investigated, it was ultimately not implemented due to the complexity of the task and time limitations of the project. However, it could be implemented in the future.

\subsection{Don't Care Reduction}
Non-truncated truth tables in Issie can have redundant rows removed via reduction with Don't Cares. This is implemented using a recursive algorithm. This functionality was tested on multiplexers, as well as combinations of logic gates and was found to work as intended. While powerful in specific cases, it has been overshadowed by algebraic reduction, which reduces the truth table to a greater extent and is far more versatile. In fact, when prompted for general feedback in the user experience questionnaire, one participant wrote:
\begin{center}
    \textit{"While the reduce button does work, the algebra feature is much better so it's kind of redundant?"}
\end{center}
While it is ironic that a feature implemented to remove redundancies in the truth table may itself be considered redundant by a user, the participant does raise a somewhat valid point. In most situations, algebraic reduction results in a smaller truth table, while the algebraic expressions are far more readable and information dense compared to numerous Don't Care (X) terms spread across rows. Another limitation of DC reduction is that it only marks inputs as redundant when they do not affect \textbf{all of the outputs} in that row. In contrast,  information on whether a given input affects a specific output can be be obtained from algebraic expressions; if the output expression does not contain a specific input label then that input is redundant with regard to that output. However, DC reduction may be useful in circuits where certain key inputs into the logic may be passed to the SEL port of a multiplexer, resulting in algebraic reduction not being as useful. 

A more solvable issue with DC reduction is that seems to not align completely with the Issie principle of obviousness. \textit{Reduce} is quite a vague term and it may be a better idea to change the button text to something like "Remove Redundancies". In addition to this, users are currently not informed when no redundancies are found in the truth table. As a result, it appears that pressing the button did nothing. Two possible solutions to this issue could be:
\begin{enumerate}
    \item Reduce button behaves like \textit{Start Simulation} or \textit{Generate Truth Table} button. The table is DC reduced in the background, and if no redundancies are found the button is greyed out.
    \item The system stays as it currently is, but if no redundancies are found in the reduction process the user is informed using a popup.
\end{enumerate}
While the former would be more intuitive and obvious, it would involve reducing the truth table in the background. This is a time-consuming process which could decrease the responsiveness of the application. On the other hand, while the latter approach would require an extra click, it would be much easier to implement. It is likely that one of these solutions will be implemented prior to the merger with the master branch of Issie.

Evaluating DC Reduction as a whole, while it is inferior to algebraic reduction, there are specific niche cases where it may still be useful. Once the features added to Issie by this project are tested by a wider user base during Digital Electronics labs at Imperial College London, a decision can be made on whether it is worth keeping in the application.

\section{Evaluation against Requirements}
This project has two main deliverables; an extended and improved version of Issie, and any appropriate documentation for the application. At the beginning of the project, a series of requirements were formalised which determined what the project should aim to accomplish, and under what circumstances could it be considered successful. 
\begin{longtblr}[
  caption = {Evaluation against Requirements},
  label = {tab:evalreqvis},
]{
  colspec = {|X[1.5]|X[5]|X[2]|},
  rowhead = 1,
  hlines,
  row{2} = {gray9},
  row{25} = {gray9},
} 
\textbf{Requirement} & \textbf{Comment} &\textbf{Implemented}? \\
& \textbf{\centering LOGIC VISUALISATION} & \\
\textbf{E1.1} & A numeric truth table can be generated for a sheet containing combinational logic. This truth table is exhaustive when the sum of input widths is under 10. Otherwise, it is still correct, but truncated.  & Yes \\
\textbf{E1.2}& A numeric truth table can be generated for a partial selection of a sheet. This truth table is exhaustive when the sum of input widths is under 10. Otherwise, it is still correct, but truncated.  & Yes \\
\textbf{E1.2.1}& New inputs and outputs are created to form a correct Issie schematic.  & Yes \\
\textbf{E1.2.2}& The newly generated inputs and outputs have intelligently inferred labels based on which component port they are connected to.  & Yes \\
\textbf{E1.3}& The truth table generation algorithm is versatile and can handle any combinational Issie schematic.  & Yes \\
\textbf{E1.3.1}& Multi-bit inputs and outputs are supported. Temporary inputs/outputs created while generating a truth table for a selected logic block  have correct widths inferred using either \codestyle{WidthInferrer} or the connected component.  & Yes \\
\textbf{E1.3.2}& Custom Components (sub-sheets) are supported, including when they are part of selections. However, all custom component ports must be connected so as to allow \codestyle{WidthInferrer} to find port widths.  & Yes \\
\textbf{E1.3.3}& Inputs, Outputs, and Viewers are all shown in the truth table  & Yes \\
\textbf{E1.4}& Users have the option to reduce the truth table using Don't Cares. This is only applicable to un-truncated tables.  & Yes \\
\textbf{E1.5}& Filtering of truth tables with input and output constraints has been implemented. Caveat on output constraints is that they only filter the generated table, so does not return the full set for a truncated table.  & Yes \\
\textbf{E1.6}& Truth tables are displayed in a clear and easy to understand format, with striping to make differentiating rows easier. Features involving truth tables are presented in a menu which can be easily explored and clicked through. Messaging is consistent and guides the user.  & Yes \\
\textbf{E1.7}& Truth table generation takes place in under 1 second, while reduction times for the largest possible table are consistently under 3 seconds. The fast generation time is due to truncation, but there is not much value in generating more rows. Furthermore, generating more rows than this makes the UI feel sluggish.  & Yes \\
\textbf{E1.8}& Graphical manipulation operations on the Truth Table, such as re-ordering rows, sorting etc. appear instantaneous (i.e. take less than 100ms).  & Yes \\
\textbf{E1.9}& Through truth table reduction and viewing of algebraic truth tables, complex relationships implemented by large circuits, such as ALUs, can be summarised using a few different expressions. & Yes \\

\textbf{D1.1}& Algebraic truth tables have been added to Issie. Expressions are calculated using algebraic simulation. & Yes \\
\textbf{D1.1.1} & Multiplexers: Both library and gate-level multiplexers are recognised correctly. Library N-bit Adders are supported, as well as Half and Full adders defined by the user using gates. User-defined ripple carry adders are not recognised perfectly, but do still give an idea of the addition. & Yes \\
\textbf{D1.1.2}& Algebraic truth table can be calculated for all combinational circuits, with the only limitation being that algebra cannot be passed to SEL ports. & Yes \\
\textbf{D1.2}& A fairly interactive truth table interface has been provided, with responsive and intuitive manipulations available. However, some additional work could be done to make the truth table more interactive. & Yes \\
\textbf{D1.2.1}& Implementing functionality where mousing over parts of the truth table could highlight parts of the schematic was considered, however this would require changing draw block behaviour. Not only would implementing this be time consuming, but outside of annotating specific IOs not much potential was seen in this approach. Other interactivity, such as highlighting cells in truth tables was considered, but was not implemented due to time constraints. & Yes \\
\textbf{D1.2.2}& Users can rearrange order of columns/rows in the truth table. & Yes \\
\textbf{D1.2.3}& Users can sort the truth table in ascending and descending order. & Yes \\
\textbf{D1.1}& The user can access truth table related functionality easily -- all features are contained within the truth table tab, and are either presented on the truth table itself (sorting and moving columns), or grouped under a labelled menu section. The user experience survey backed this up. & Yes \\
& \textbf{\centering SOFTWARE/DOCUMENTATION QUALITY} & \\
\textbf{E2.1} & The project has delivered performant, working, bug-free code which adheres to Issie's code guidelines and other principles such as "MVU-ness". Performance has been tested quantitatively, while correctness and resistance to failure has also been verified.  & Yes \\
\textbf{E2.2} & XML comments have been written for all functions in the delivered code, alongside other inline comments to explain how certain key parts work in order to make the codebase more maintainable for future developers.  & Yes \\
\textbf{E2.3} & Code has been written with maintainability in mind. Care has been taken to use standard library data structures and functions as much as possible, and any newly introduced types and processes have been documented extensively in the code.  & Yes \\
\textbf{D2.1} & Certain UI changes, such as moving the Waveform simulator and fixing bugs related to the dividerbar were implemented. The UI was not redesigned , however it was evaluated and its current form appears to be adequate.  & Partially \\
\textbf{D2.2} & The Issie website was not updated over the duration of the project itself. However, it will be updated in due course.  & Not yet \\
\end{longtblr}

% \begin{longtblr}[
%   caption = {Evaluation against Software/Documentation Quality Requirements},
%   label = {tab:evalreqvis},
% ]{
%   colspec = {|X[1.5]|X[5]|X[2]|},
%   rowhead = 1,
%   hlines,
% } 
% \textbf{Requirement} & \textbf{Comment} &\textbf{Implemented}? \\

% \textbf{E2.1} & The project has delivered performant, working, bug-free code which adheres to Issie's code guidelines and other principles such as "MVU-ness". Performance has been tested quantitatively, while correctness and resistance to failure has also been verified.  & Yes \\
% \textbf{E2.2} & XML comments have been written for all functions in the delivered code, alongside other inline comments to explain how certain key parts work in order to make the codebase more maintainable for future developers.  & Yes \\
% \textbf{E2.3} & Code has been written with maintainability in mind. Care has been taken to use standard library data structures and functions as much as possible, and any newly introduced types and processes have been documented extensively in the code.  & Yes \\
% \textbf{D2.1} & Certain UI changes, such as moving the Waveform simulator and fixing bugs related to the dividerbar were implemented. The UI was not redesigned , however it was evaluated and its current form appears to be adequate.  & Partially \\
% \textbf{D2.2} & The Issie website was not updated over the duration of the project itself. However, it will be updated in due course.  & Not yet \\

% \end{longtblr}


\section{Summary}
In this section, the updated version of Issie delivered by this project was evaluated against the initial project aims, Issie's Core Principles, and the requirements set out at the beginning of the project. In the first two sections, using user questionnaire results, observations made about the application, and other results from the testing stage, it was established that all project aims had been met and all core principles had been maintained. In the evaluation against requirements, it was established that all Essential requirements, and all bar one Desired requirements, have been fulfilled by the project.
Certain areas of possible improvements were also identified. Three issues with Don't Care reduction were found -- these are a lack of obviousness, possible redundancy in the system, and performance. While the first issue has a fairly straightforward fix that will most likely be implemented soon, the others will require further analysis and effort to solve. Cases where certain features could be improved were also identified. This includes expanding the algebraic reduction rules to cover more cases, and implementing algebraic output constraints. 

To summarise, the updated version of Issie delivered by this project comfortably fulfils all of the metrics and requirements defined for it at the beginning of the project. Therefore it, and the project as a whole can be considered a success.

% The bare minimum expectation of the project is that it \textbf{must} fulfil all Essential Requirements outlined in the Requirements Capture (Chapter \ref{chap:requirements}). Anything less than this would suggest that the project was not successful in achieving its goals. The only exception to this would be that if, during the development process, a feature outlined by a requirement was deemed to be unnecessary and therefore changed. The success of the project will also be measured on how many of the Desired Features are fulfilled, with the ideal scenario being that all requirements are satisfied. 

% Most of the outlined requirements are features that the final deliverable should incorporate. Therefore, these requirements can simply be evaluated by opening the application and testing that they work as intended. The correctness of such features can be tested by opening existing Issie schematics featuring various circuits built by users, and checking if the added features perform as expected when used on those sheets. Additionally, testing will occur throughout the development process - each feature will be unit tested prior to its integration to Issie. 
% In contrast to the type mentioned above, certain requirements cannot be objectively judged as complete, such as those related to intuitiveness of the UI. The subjective nature of such requirements mandates that their satisfaction be evaluated by multiple end-users. Therefore, the chosen evaluation methods for Requirements \textbf{E1.6}, \textbf{E1.7}, and \textbf{D3.1} will be a survey answered by volunteers who have spent time using the delivered application to perform a series of basic tasks.

% \section{Overall Evaluation}
% The overall aim of the project is to improve Issie as a digital electronics education tool and as a logic design application. The effectiveness of the features this project will add must be judged by those who stand to benefit from them - the user base. Therefore, the survey mentioned in the previous section will also include questions on if the newly added features helped them in designing the logic specified in the tasks. For one task in the survey the group will be split into two teams, with one using the original version of Issie and the other the one delivered by this project. The students will be given a series of custom components which implement increasingly complex, but still identifiable logic. The students will be asked to use Issie to identify which actual component the custom component implements using the tools their version of Issie provides them. The amount of time it takes them to reach an answer, and the correctness of that answer, will contribute to their score. The correlation between scores and Issie version will be observed and used to evaluate the version of Issie delivered by this project.