\chapter{Testing \& Results}
The delivered improved version of Issie was tested from the perspectives of \textbf{correctness} and \textbf{performance}. Testing the correctness of the improvements made to Issie included checking that the implemented functionality worked as intended, as well as ensuring that the application was stable, not crashing regardless of user input. Performance testing was also approached from two angles; firstly the time taken for specific actions and processes was measured quantitatively and compared to Robert Miller's \cite{Miller1968ResponseTI} classes for perceived responsiveness of an application. Secondly, a more qualitative and holistic test of the application was conducted by manually using the application and judging whether Issie felt responsive or sluggish.

\section{Testing Application Stability}
An application is considered stable when the user is not subjected to undefined behaviour or inexplicable crashes while using the application. The stability of the improved version of Issie delivered by the project was verified by analysing cases in the codebase which could trigger a system crash, and systematically evaluating that they could not occur. There are two scenarios which can cause Issie to crash:
\begin{itemize}
    \item Un-handled exceptions: exceptions can either be generated by the developer or can be generated by library functions. If these exceptions are not caught and handled appropriately, the cause the application to crash.
    \item When \codestyle{failwithf} is called in the code: this function is called when an unexpected case that should never occur is matched in the code. An example of this would be if the Update function receives the instruction to reduce a truth table with Don't Cares when no truth table exists.
\end{itemize}

\subsection{Exception Analysis}
The code added to Issie was analysed to explore the scenarios in which exceptions could be raised. Exceptions are uncommon in F\fsharp -- instead the use of Monad types such as \codestyle{Option} and \codestyle{Result} is preferred. When using Monad types, failure of an operation is an option and the programmer is made to account for the possibility of it while programming. In contrast, functions which return exceptions place the onus of verifying the arguments prior to the call on the developer. An example of this is the difference between the functions \codestyle{Map.find} and \codestyle{Map.tryFind}; both functions look up a key in a Map and return the corresponding value, but return the value in different ways. When a key exists, \codestyle{Map.find} returns the value, but when it does not exist it raises an exception. If the developer fails to account for this, the program may crash unexpectedly. In contrast \codestyle{Map.tryFind} wraps the returned value in the \codestyle{Option} type, and returns \codestyle{Some value} if the key exists in the Map, or \codestyle{None}. Therefore, when using \codestyle{Map.tryFind}, the developer must always actively handle the failure case at that point in the code, either providing alternate behaviour or manually making the choice to fail the application with \codestyle{failwithf}. This significantly reduces the chance of application crashes due to an oversight made by the developer with regard to exception handling. 

All library functions used in the code written during the project were analysed, and it was checked which of the ones used could possibly return any exceptions. For each of these functions a strategy was devised to check whether an exception could occur in practice:

\begin{table}[ht]
    \centering
    \begin{tabular}{|m{3cm}|m{9cm}|m{2cm}|}
    \hline
        Function &  Check & Pass/Fail\\ \hline
        \codestyle{List.except} & Ensure that the items to exclude sequence can never be null. & Pass \\\hline
        
        \codestyle{List.head} & Ensure that the supplied list is not empty either through a conditional statement or pattern match case on the list. & Pass \\ \hline
        
        \codestyle{List.updateAt} & Ensure that the index is valid (between 0 and length-1) either through a bounds check or from properties. & Pass \\ \hline
        
        \codestyle{Seq.allPairs} & Ensure that the both sequences can never be null. & Pass \\\hline
        
        \codestyle{Seq.append} & Ensure that the both sequences can never be null. & Pass \\\hline
        
        \codestyle{Seq.init} & Ensure that the count can never be negative. & Pass \\\hline
        
    \end{tabular}
    \caption{Caption}
    \label{tab:my_label}
\end{table}

Exceptions can also be raised in the code by the developer if required, and caught using a \codestyle{try-catch} block. This project only adds one such exception; the \codestyle{AlgebraNotImplemented} exception which is be raised in the Fast Simulation function \codestyle{fastReduce} when algebra is passed to an unsupported port or component. An exception is used here because manually propogating a \codestyle{SimulationError} up the call stack would be very impractical. The \codestyle{AlgebraNotImplemented} exception contains a \codestyle{SimulationError} data structure; whenever there is a scenario in which algebra is fed to the Fast Simulation, there is a \codestyle{catch} block waiting to catch any the exception and return the \codestyle{SimulationError} contained within. Additionally, the XML documentation of functions in the Fast Simulator has been updated to reflect the new exception. Therefore, it can be said that the code added by this project to Issie is stable from an exception point-of-view.

\subsection{Failure Analysis}
To ensure that the application could not fail during use, every \codestyle{failwithf} case in the project code was inspected, and a summary made of the scenarios in which the function would be called. Once the scenario was ascertained, one of two actions woere taken. If the fail case was related to application state, it was ensured through thorough inspection of the code that such a state could never occur. If the fail case was related to the UI, testing involved attempting to create those circumstances in the application. In all cases, attempts to achieve scenarios that would call the application to fail and exit were unsuccessful. From over 5 hours of user testing, which involved generating truth tables from a variety of schematics and manipulating them, not a single crash was observed.

\section{Correctness Testing}
Correctness of the implemented features was tested by testing the features on 6 different circuits, each of varying complexity. These circuits can be described as:
\begin{itemize}
    \item A two-input multiplexer circuit implemented only using gates
    \item A circuit containing a Mux4 component with 2-bit inputs to each data line of the multiplexer
    \item A circuit which calculates the bitwise And of two 8-bit inputs
    \item A circuit which either adds or subtracts two 16-bit values depending on the selected mode
    \item An 8-bit ALU, which is a custom component in the design of an 8-bit CPU
    \item An 8-bit CPU design
\end{itemize}

The following features were manually evaluated and confirmed to be working for all tested schematics (where relevant):
\begin{enumerate}
    \item For all combinational circuits, a numeric truth table can be generated for the whole sheet.
    \item For all valid selections of a schematic, a numeric truth table can be generated:
    \begin{enumerate}
        \item The selected canvas is corrected successfully, with newly generated input or output components.
        \item Newly generated IOs are labelled based on which component ports they connect to.
        \item Truth tables for selections can be generated even if errors or sequential components exist elsewhere in the schematic.
    \end{enumerate}
    \item If there are errors in the schematic, the \textit{See Problems} button appears in place of the \textit{Generate Truth Table} button, and clicking it conveys the error to the user.
    \item For all circuits where the total width of all the inputs combined exceeds 10 bits, a truncated truth table of 1024 rows is displayed, along with a warning notification informing the user about the truncation.
    \item The base of numbers in the truth table can be changed using the base selector.
    \item Truth table related functionality can be shown and hidden by expanding and closing menu sections.
    \item Input constraints can be applied to the truth table and successfully change the input state so that rows that were previously truncated are now generated and displayed.
    \item Significantly restrictive input constraints will reduce the input space enough so the truth table will no longer be truncated.
    \item Output constraints filter the existing truth table.
    \item There is an intuitive interface for adding/removing constraints:
    \begin{enumerate}
        \item Clicking on the \textit{Add} button opens the constraint editor popup.
        \item Changing the chosen IO in the IO selection section updates the IO displayed in the editor section.
        \item Real-time validation of constraints is performed as they are entered, with errors clearly conveyed to the user.
        \item Constraints that are currently being applied are clearly displayed to the user with tags, and can be deleted easily by clicking the cross next to them.
        \item All constraints can be cleared in one go with the \textit{Clear All} button.
    \end{enumerate}
    \item Columns in the truth table can be hidden by using the column hider toggles.
    \item Rows in the truth table can be sorted based on a chosen IO, in ascending and descending order.
    \item The sorting information is conveyed to the user successfully through the highlighting of the relevant sorting arrow.
    \item The order of columns in the truth table can be changed.
    \item Non-truncated truth tables can be reduced with Don't Cares, with the resultant table containing no redundant rows.
    \item Users are prevented from reducing truncated truth tables.
    \item Users can change some or all inputs to algebra in the truth table:
    \begin{enumerate}
        \item Clicking the algebra button always spawns the algebra selector popup, where inputs can be toggled between numeric and algebraic values.
        \item If a certain input is not supported as being algebraic, the user is informed of the reason why. They are prevented from applying the incompatible algebraic inputs.
        \item When algebraic inputs are in the truth table, the outputs are informative algebraic expressions which is a correct function of the inputs.
        \item Intelligent calculation and simplification rules described in Table \ref{tab:fastReduce} and in the explanation of \codestyle{evalExp} are applied correctly.
    \end{enumerate}
    \item Algebraic expressions are printed correctly in the truth table.
    \item When the truth table tab is open, width of the right section can be changed using the draggable dividerbar.
    \item The truth table is responsive:
    \begin{enumerate}
        \item Changing the width of the right section changes the width of the truth table (therefore of the columns in the table).
        \item When the content inside a truth table cell is too wide, the height of the row automatically adjusts so that the content can wrap to the next line.
    \end{enumerate}
    \item The waveform simulation can successfully be run from the new Waveform Simulator sub-tab.
\end{enumerate}

\section{Quantitative Performance Testing}
The three following schematics were used for measuring the performance of the application, with each having slightly different attributes.
\begin{enumerate}
    \item A circuit containing a Mux4 component with 2-bit inputs to each data line of the multiplexer. In total, this circuit has 5 2-bit inputs, meaning that it will generate exactly 1024 rows (no truncation required). This is a simple circuit with only one component, so should be quick to simulate. However, there are many redundancies in the truth table, so Don't Care reduction may take longer.
    \item A circuit which either adds or subtracts two 16-bit values depending on the selected mode. This circuit features slightly more complex logic than the previous one, and also will result in the truth table being truncated. This will be referred to as the 'Add Or Sub' schematic.
    \item An 8-bit ALU, which is a very complex schematic featuring lots of library and custom components. This should test the generation algorithm to the maximum.
\end{enumerate}

\subsection{Generating Numeric Truth Tables}
The time taken to generate a numeric truth table was measured for all three aforementioned schematics.
\begin{table}[!ht]
    \centering
    \begin{tabular}{|l|l|l|l|l|l|l|}
    \hline
        Sheet & Trial 1 & Trial 2 & Trial 3 & Trial 4 & Trial 5 & Average \\ \hline
        Mux4 & 52 & 58 & 51 & 49 & 51 & 52.2 \\ \hline
        Add Or Sub & 75 & 72 & 69 & 81 & 78 & 75 \\ \hline
        ALU & 697 & 702 & 700 & 697 & 702 & 699.6 \\ \hline
    \end{tabular}
    \caption{Time taken to generate a numeric truth table (ms)}
    \label{tab:timeTT}
\end{table}

\subsection{Algebraic Truth Tables}
The time taken to calculate an algebraic truth table for the 8-bit ALU was measured. The circuit had five inputs in total: A and B which were 8 bits, X and F which were 3 bits, and Cin which was 1 bit. A, B, and Cin were set as algebraic inputs for the experiment. Five trials were carried out, and the average time was calculated. 

\begin{table}[!ht]
    \centering
    \begin{tabular}{|l|l|l|l|l|l|}
    \hline
        Trial 1 & Trial 2 & Trial 3 & Trial 4 & Trial 5 & Average \\ \hline
        45 & 42 & 44 & 47 & 45 & 44.6\\ \hline
    \end{tabular}
    \caption{Time taken to generate an algebraic truth table for the ALU schematic (ms)}
    \label{tab:timeAlgTT}
\end{table}

\subsection{Don't Care Reduction}
The time taken to reduce an existing truth table using Don't Cares was measured for two schematics. The Mux4 schematic was first tested, as it contains multiple redundancies and therefore requires repeated rounds of reduction. Secondly, the 'Add Or Sub' schematic was tested. As this schematic exceeds the bit limit, the input space was limited; inputs A and B were constrained to between 0 and 16. This schematic was chosen as there are no redundant rows in the truth table, as every input contributes to the output. This represents a scenario in which no DC rows are valid, and therefore the process will stop after one round of attempted reduction.

\begin{table}[!ht]
    \centering
    \begin{tabular}{|l|l|l|l|l|l|l|}
    \hline
        Sheet & Trial 1 & Trial 2 & Trial 3 & Trial 4 & Trial 5 & Average \\ \hline
        Mux4 & 2590 & 2586 & 2589 & 2616 & 2598 & 2595.8 \\ \hline
        Add Or Sub & 265 & 263 & 260 & 259 & 263 & 262 \\ \hline
    \end{tabular}
    \caption{Time taken to reduce a numeric truth table using Don't Cares (ms)}
    \label{tab:timeDCTT}
\end{table}

\subsection{Graphical Manipulation of Truth Tables}
Using the truth table generated for the ALU schematic, the time taken to perform three graphical manipulations was measured. These manipulations were: hiding an output column, sorting the truth table, and moving a column. The ALU schematic was chosen as it will generate a truncated truth table, meaning that the maximum possible 1024 rows will be rendered. It also contains 8 IOs, which is a sizeable amount.

\begin{table}[!ht]
    \centering
    \begin{tabular}{|l|l|l|l|l|l|l|}
    \hline
        Operation & Trial 1 & Trial 2 & Trial 3 & Trial 4 & Trial 5 & Average \\ \hline
        Sorting Truth Table & 35 & 33 & 36 & 41 & 39 & 36.8 \\ \hline
        Moving a Column & 21 & 25 & 22 & 23 & 27 & 23.6 \\ \hline
        Hiding a Column & 43 & 38 & 37 & 39 & 38 & 39 \\ \hline
    \end{tabular}
    \caption{Time taken to conduct different graphical manipulations on a truth table (ms)}
    \label{tab:timeTTManip}
\end{table}